## [Tcp编程常见问题及解决方法总结](https://www.cnblogs.com/wenjingu/p/3809778.html)
### 问题1、粘包问题

* 解决方法一：TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；

* 解决方法二：发送固定长度的消息

* 解决方法三：把消息的尺寸与消息一块发送

* 解决方法四：双方约定每次传送的大小

* 解决方法五：双方约定使用特殊标记来区分消息间隔

* 解决方法六：标准协议按协议规则处理，如Sip协议

### 问题2、字符串编码问题

将中文字符串用utf8编码格式转换为字节数组发送时，一个中文字符可能会占用2～4个字节（假设为3个字节），这3个字节可能分3次接收，接收端每次接收完后用utf8编码格式转换为字符串，就会出现乱码，并导致接收长度计算错误的情况。

* 解决方法一：以字节数做为消息长度的计算单位，而不是字符个数。

* 解决方法二：发送方和接收方都采用unicode编码格式。

### 问题3、长连接的保活问题

标准TCP层协议里把对方超时设为2小时，若服务器端超过了2小时还没收到客户的信息，它就发送探测报文段，若发送了10个探测报文段（每一个相隔75S）还没有收到响应，就假定客户出了故障，并终止这个连接。因此应对tcp长连接进行保活。

以下是异步通信时会遇到的问题：

### 问题4、缓冲区脏数据问题

同步发送的拷贝，是直接拷贝数据到基础系统缓冲区，拷贝完成后返回；

异步发送消息的拷贝，是将Socket自带的Buffer空间内的所有数据，拷贝到基础系统发送缓冲区，并立即返回；

因此异步发送时缓冲区设置不好会导致接收到脏数据的问题，如下所示：

第一次发送数据：1234567890

第一次接受数据：1234567890

第二次发送数据：abc

第二次接受数据：abc4567890

请参考：http://www.cnblogs.com/tianzhiliang/archive/2010/09/08/1821623.html

* 解决方法一：将缓冲区的大小设置为实际发送数据的大小。

### 问题5、内存碎片问题

频繁的申请缓冲区会导致内存碎片的问题。

* 解决方法一：使用对象池和内存池。

请参考MSDN：http://msdn.microsoft.com/zh-cn/library/bb517542(v=vs.100).aspx

http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socketasynceventargs.socketasynceventargs(v=vs.100).aspx

### 问题6、乱序问题

多个线程使用异步通信方式向同一个接收端(socket)同时发送数据，会导致接收端接收的数据混乱。如下所示：

线程1第一次发送：123456789，假设未发送完，只发送了123

线程2第一次发送：abcdefgh，假设未发送完，只发送了abc

线程1第二次发送：456789，发送完成

线程2第二次发送：defgh，发送完成

接收端最终接收的数据为：123abc456789defgh。

* 解决方法一：一个连接的发送端线程排队发送数据。
